Создаем файл гитконфиг, где будет содержаться наш файл с емейлом и именем пользователя C:\Users\a.guskov>copy NUL .gitconfig и нажать энтер
Добавляем информацию в файл .gitconfig о емейле и имени пользователя, открываем этот файл как текстовый редактор и пишем [user] кнопка Tab email=av.guskov@rambler.ru user=aguskov
сохраняем ctrl+s
проверяем есть ли эта информация в гите, открываем командную строку и пишем git config --list --global и нажать энтер, данные отобразились
зарегистрировать в github
email - av.guskov@rambler.ru
pass - 9jc3g88gh5sa4i5
username - a-guskov
создал первый репозиторий https://github.com/a-guskov/Pervyy-repository.git
клонируем созданный репозиторий на наш компьютер
создать папку github
перейти в эту папку, в ком.стр. пишем cd C:\Users\a.guskov\Desktop\github (путь созданной папки), состаялся переход в папку C:\Users\a.guskov\Desktop\github>
клонируем удаленный репозиторий, в ком.стр. пишем git clone https://github.com/a-guskov/Pervyy-repository.git (созданный репозиторий)
перейти в папку клонированного репозитория, в ком.ст. cd C:\Users\a.guskov\Desktop\github\Pervyy-repository (адрес папки)
проверяем, что с этим репозиторием, пишем в ком.ст. git status
создаем в папке репозитория любой файл, в физической например file1
отследим изменения в нашем репозитории, в ком.ст. git status, нашли file1, он находится на локальной машине, но не в репозитории
добавим в file1 текст в папке на компе, например 123
показываем гиту, что были изменения, в к.с. пишем git add file1.txt и после проверяем в к.с. пишем git status, файл внесен в систему
внесем еще изменения в file1, например напишем 456, в к.с. пишем git status, показывает 2 состояния файла (new file и modified file)
2 пути решения:
1.Откатиться к первому файлу, где есть только 123
2.Согласиться с этим изменением - пишем git add file1.txt потом проверим пишем git status и в результате остается один файл, а состояние измененное пропало
файл находится пока удаленно, чтобы проверить зайдем в сущ.й репозиторий на гите (в нем пусто)
Сделаем комит, в к.с. пишем git commit -m "test commit 1" (просто так назвали) 
Проверяем статус, пишем в к.с. git status и на него нет информации, т.к. мы совершили комит. Но он находится в нашем репозитории
Закидываем комит на удаленный репозиторий, в к.с. пишем git push, закинуло на страницу авторизации, в гите обновляем страницу и видем наш файл
В гите можно редактировать этот файл ,смотреть ветки и т.д.
На локальном компе можно это делать не через командную строку, а через git bush (подобие к.с. можно использовать линукс команды и команды гита)
Изменяем документ в гите, добавляем новую строчку, например 789.
Дальше в поле Commit changes нужно написать какие изменения мы внесли (added new line) и нажимаем на кнопку Commit changes
Есть изменения в файле гита, но локальный репозиторий это не видит
Заходим в лок. реп.й, нажимаем например на git bush here, появилась к.с. гитбаша
Пишем команду git status, чтобы проверить есть ли изменения, их не видно
Просмотрим содержимое файла file1 (команда идентична с линуксовской), cat file1.txt - показывает содержимое файла (123 456) на локальной машине
Смотрим, какие изменения есть на удаленном репозитории, git fetch
Дальше проверим статус, git status - увидим, что наша локальная ветка отстает на 1 комит
Веьтка origin/master(main) - находится на локальном репозитории, а ветка origin master(main) - на удаленном
Чтобы увидеть изменения на удаленной ветке и привести их на локальную пишем, git pull
Проверяем статус, git status - ветка не имеет изменений (обновилась)
Проверяем содержимое файла в локальной машине, cat file1.txt - показывает уже все с изменениями (123 456 789.)
Появился номер, хэш нашего комита (updating 864d9e3..2d725fc), по этому номеру можно отследить все изменения, которые проводились
Увидеть все комиты, которые были, git log - после нажать на q, чтобы прекратить поступление логов, иначе не сможем продолжить работать дальше
Можно посмотреть изменнения, которые делали опр. авторы, git log --author a-guskov - покажет все комиты, сделанные данным автором
Можно посмотреть содержание любого комита, git show 2d725fc15bbcb21f87518f1e8c61cb5698b655dd (номер комита) - покажет все изменеия комита
Показать последний комит - git show, без номера комита
Узнать информацию об авторе строки файла, git blame file1.txt - показывает построчно фамилии
Можно узнать кто вносил изменения по конкретной строке, git blame file1.txt | grep 123
Можно узнать автора, каките строки он изменял, git blame file1.txt | grep a-guskov
Добавим изменение в лок.й файл, echo "add line" >> file1.txt - добавляет сроки в цеелевой файл
Проверяем, добавилась ли строка в файл, cat file1.txt - (123 456 789. add line).
Проверяем статус, git status - файл находится в состоянии модифайд
Посмотреть изменения в файле, git diff - покажет содержимое и +add line
Cинхронизируем лок.й и удаленный репозиторий, git add file1.txt
Проверим статус, git status
Проведем комит, git commit -m "new commit"
Тепрь пушим, git push - теперь все ветки синхронизированы между собой
Переходим в гит и проверяем - все строки совпадают
Открываем gitbash и смотрим, что у нас содержится в каталоге, ls - показывает файлы, какие есть
Создадим новый файл, echo "new line" >> new.file - файл создался на локалке
Создадим в file1 новую строку, например commit test
Проверяем статус файлов, git status - один новый файл, второй модифайд
Делаем комит, git commit -a (значит все файлы) -m (сообщение, что содержит комит) "new commit" - видит только измененный файл, нового не видит, т.к. мы его не добавили
Отменяем коммит, возвращаясь к старому состоянию, git reset HEAD~1 - вернуться на один шаг назад - отменилась модификация файла1
Проверим статус, git status - будет отображаться действия до комита - изменения файла1 и добавление нового файла
Cделаем еще раз комит, git commit -am "new commit" - 1 файл изменился (закомитился)
Делаем новый файл видимым, добавляем его, git add new.file
Проверим статус, git status - будет отображаться два файла
Закомитим изменения, git commit -am "test" - файл добавился в удаленный репозиторий
Добавим один файл на github, нажать на кнопку add file-> create file  написать в нем +test в описании написать Create conflict, в названии написать conflict и нажать кнопку Commit new file
Заливаем в удаленный репозиторий с локального, git push - случился конфликт, т.к. эти два репозитория не похожи
Для этого используем сначала заливку на локальный реп., git pull - уровняли версии на удаленном и локальном
Заливаем на удаленный версию с локального, git push теперь на уд. реп.и все три файла (file1, conflict, new.file)
Проверить совпадение уд. реп. с лок., git pull - ответ Already up to date (все норм, оба репозитория синхронизированы)
Еще один конфликт, если изменить файл в лок. и удал. и сделать статус, будет файл модифайд
Проверим изменения в лок.реп., git diff
Закомитим изменения, git commit -am "tetss" - cоздали комит
Теперь пробуем залит туда и обратно, git push и git pull - появится ошибка (конфликт), т.к. разные измененные строки в файле на уд. и лок. репозитории
Уладим конфликт, есть два способа:
1.Если мы не знаем какие изменения прошли, обращаться к разработчику, он напишет команду, git merge --abort и потом git status - изменений не будет (все удалено)
2.Еще раз воспроизведем ошибку, git pull потом git status - появится состояние both modified (два файла были модифицированы)
Заходим в лок.р. в file1 сама система подсвечивает где конфликт (открыть файл notepad++) - удаляем ненужные строки и оставляем две нужные filing testing и unfiling testing
Заливаем изменения, "git add .", "git commit -am "test"", "git push" - роверяем информацию в уд.реп. - должны совпадать
Проверим в лок.реп., cat file1.txt - значения совпадают
Добавим новую строку, echo "3line" >> file1.txt (на лок.реп.) строка добавилась
Если есть изменения в файлах и мы хотим их откатить, git checkout file1.txt - последняя строка "3line" убралась 
Добвам две строки в разные файлы: echo "line11" >> new.file и echo "line11" >> conflict
Проверяем добавление строк: cat new.file и cat сonflict - строки добавлены
Чтобы откатить все последние изменения, git checkout .  - изменения во всех файлах убрались
Добвам строку : echo "futo" >> conflict
Убрать изменения не навсегда, а во временное хранилище, git stash и проверяем содержимое cat conflict - изменение скрылось
Вернуть изменения, git stash pop - все вернулось (строка futo), проверяем командой cat сonflict








































